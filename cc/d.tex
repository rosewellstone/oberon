\section{1978: Lilith}
Recognizing this difference, I simply could not imagine how to return from my
sabbatical to the conventional computing environment, in which one communicated
with a main frame computer over a thin wire with 300 b/s sitting in front of a dumb
terminal. But how could I avoid this dire fate? As a workstation of this caliber was
unique, and because it could not be bought, the only way out was to build one. But
this was a difficult decision to make. I had to build up a team and a workshop with
electronic equipment. I was lucky in succeeding in both endeavors, and within only
2 years in 1978 a prototype of a workstation was in operation. We called it Lilith,
according to Adam's 1st wife, who, after having been kicked out of paradise,
seduced men at night, just as our Lilith seduced researchers to stay at work in the
evenings and over weekends. It was a truly exciting project with concurrent
development of hardware and software by a team of only 4 - 7 people.

The hardware of Lilith was a 16-bit computer built (mostly) of Shottky TTL parts.
Lilith consisted of about 8 boards in a 19‚Äù rack. The heart was the processor
(board) with 4 bit-slice chips Am2901. They constituted the ALU with 16 registers
and the usual arithmetic and logical operations. We augmented them with an
external stack memory and a barrel shifter. Lilith was to be a computer with a short
stack for the evaluation of expressions. This fast memory was built of 4 748S189
chips, 16x4 RAMs. The barrel shifter was an essential feature, necessary to
perform fast bitmap operations, placing data at any bit position rather than at word
boundaries within only one clock tick. The shifter consisted of 8 Am 25S10 chips.
The main memory was built with 64 16K-bit DRAM chips.

Like the Alto, Lilith was micro-coded. That is, the externally visible computer was
represented by a single program interpreting M-code, code generated by the
Modula compiler. This microcode consisted of 40-bit micro-instructions residing in
the microcode memory consisting of five 2K x 8 EEPROMs (2716). In every clock
cycle (7 MHz, 140 $\mu$s), one micro-instruction is decoded and executed by the
Am2901 processor chips. The control unit, generating the address of the next
instruction consisted of 3 Am2911 sequencer chips, accommodating addresses of
12 bits. Microcode was the most convenient solution to implement a relatively
complex instruction set with a modest amount of hardware. The instruction set of
Lilith was indeed quite complex. This was due to the need of M-code being dense,
again in order to store complex programs in a relatively small main memory (64K
words). One contribution to the density of M-code came from Lilith's expression
stack organization, but the other, more significant contribution came from load and
store instructions with different address lengths or operand (constant) lengths.
They came in versions with addresses of lengths 4, 8, and 16. Extensive program
analysis had shown that about 80\% of instructions had addresses less than 16 (4
bits), because they referenced local variables. Analysis also showed that our M-
code was much shorter than code for then popular microprocessors, shorter by a
factor of 1.5 against the NS32000, of 2 for the Motorola 68000, and of 2.5 for the
Intel 8086. After all, this was significant, because at the time memory was (still) a
scarce resource.

A particular advantage of micro-processing was that instructions could be of very
different complexity. The shortest and fastest ones, like load and store, took only
two or three micro-cycles (i.e. less than half a microsecond), whereas others, such
as those for display operations for drawing lines and characters, were themselves
short programs including loops. As a result, Lilith snowed a fantastic performance
in displaying lines and characters on the bit-mapped display.

However, this had only been achieved with some trickery. With 1 bit/pixel (no
color!) a display page consisted of 808x606 = 489648 pixels = 30603 words. With
a refresh frequency of 50 Hz, this left an access time of (less than) 0.65 $\mu$s per
word, which would have (more than) monopolized the memory by the display. The
trick consisted of providing aside of the regular 16-bit read port, a 2nd read port
of 64 bit width for the display processor. With this solution, the display would block
the memory for only about 25\% of time.
